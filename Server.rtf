{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red89\green138\blue67;\red23\green23\blue23;\red202\green202\blue202;
\red183\green111\blue179;\red70\green137\blue204;\red194\green126\blue101;\red212\green214\blue154;\red167\green197\blue152;
\red205\green173\blue106;\red140\green211\blue254;}
{\*\expandedcolortbl;;\cssrgb\c41569\c60000\c33333;\cssrgb\c11765\c11765\c11765;\cssrgb\c83137\c83137\c83137;
\cssrgb\c77255\c52549\c75294;\cssrgb\c33725\c61176\c83922;\cssrgb\c80784\c56863\c47059;\cssrgb\c86275\c86275\c66667;\cssrgb\c70980\c80784\c65882;
\cssrgb\c84314\c72941\c49020;\cssrgb\c61176\c86275\c99608;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl360\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 /* udp_server.c */\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 /* Programmed by Adarsh Sethi */\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 /* Sept. 13, 2018 */\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <ctype.h>\cf6 \strokec6           \cf2 \strokec2 /* for toupper */\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <stdio.h>\cf6 \strokec6           \cf2 \strokec2 /* for standard I/O functions */\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <stdlib.h>\cf6 \strokec6          \cf2 \strokec2 /* for exit */\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <string.h>\cf6 \strokec6          \cf2 \strokec2 /* for memset */\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <sys/socket.h>\cf6 \strokec6      \cf2 \strokec2 /* for socket, sendto, and recvfrom */\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <netinet/in.h>\cf6 \strokec6      \cf2 \strokec2 /* for sockaddr_in */\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 #include\cf6 \strokec6  \cf7 \strokec7 <unistd.h>\cf6 \strokec6          \cf2 \strokec2 /* for close */\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 #define\cf6 \strokec6  \cf8 \strokec8 STRING_SIZE\cf6 \strokec6  \cf9 \strokec9 1024\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2 /* SERV_UDP_PORT is the port number on which the server listens for\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2    incoming messages from clients. You should change this to a different\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2    number to prevent conflicts with others in the class. */\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf5 \cb3 \strokec5 #define\cf6 \strokec6  \cf8 \strokec8 SERV_UDP_PORT\cf6 \strokec6  \cf9 \strokec9 3636\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf6 \cb3 \strokec6 double\cf4 \strokec4  timeoutLen;\cb1 \
\cf6 \cb3 \strokec6 typedef\cf4 \strokec4  \cf6 \strokec6 struct\cf4 \strokec4  dataPacket\{\cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3   \cf6 \strokec6 int\cf4 \strokec4  dataCount;\cb1 \
\cb3   \cf6 \strokec6 int\cf4 \strokec4  sequenceNumber;\cb1 \
\cb3   \cf6 \strokec6 char\cf4 \strokec4  data[\cf9 \strokec9 80\cf4 \strokec4 ];\cb1 \
\cb3 \} dataPacket;\cb1 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf6 \cb3 \strokec6 int\cf4 \strokec4  receivedSequence;\cb1 \
\cf6 \cb3 \strokec6 int\cf4 \strokec4  dataLength;\cb1 \
\cf6 \cb3 \strokec6 int\cf4 \strokec4  expectedSequence = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cf6 \cb3 \strokec6 int\cf4 \strokec4  ackSequence = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cf6 \cb3 \strokec6 char\cf4 \strokec4  ack[\cf9 \strokec9 2\cf4 \strokec4 ];\cb1 \
\cf6 \cb3 \strokec6 float\cf4 \strokec4  inputPacketLossRate;\cb1 \
\cf6 \cb3 \strokec6 float\cf4 \strokec4  inputACKLossRate;\cb1 \
\
\cf6 \cb3 \strokec6 int\cf4 \strokec4  \cf8 \strokec8 packetLoss\cf4 \strokec4 ()\{\cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3     \cf6 \strokec6 double\cf4 \strokec4  random = \cf8 \strokec8 drand48\cf4 \strokec4 ();\cb1 \
\cb3     \cf5 \strokec5 if\cf4 \strokec4  (random<inputPacketLossRate)\{\cb1 \
\cb3         \cf5 \strokec5 return\cf4 \strokec4  \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3     \}\cb1 \
\cb3     \cf5 \strokec5 else\cf4 \strokec4 \{\cb1 \
\cb3         \cf5 \strokec5 return\cf4 \strokec4  \cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3     \}\cb1 \
\cb3 \}\cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf6 \cb3 \strokec6 int\cf4 \strokec4  \cf8 \strokec8 ackLoss\cf4 \strokec4 ()\{\cb1 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3     \cf6 \strokec6 double\cf4 \strokec4  random = \cf8 \strokec8 drand48\cf4 \strokec4 ();\cb1 \
\cb3     \cf5 \strokec5 if\cf4 \strokec4  (random<inputACKLossRate)\{\cb1 \
\cb3         \cf5 \strokec5 return\cf4 \strokec4  \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3     \}\cb1 \
\cb3     \cf5 \strokec5 else\cf4 \strokec4 \{\cb1 \
\cb3         \cf5 \strokec5 return\cf4 \strokec4  \cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3     \}\cb1 \
\cb3 \}\cb1 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf6 \cb3 \strokec6 int\cf4 \strokec4  \cf8 \strokec8 main\cf4 \strokec4 (\cf6 \strokec6 void\cf4 \strokec4 ) \{\cb1 \
\
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3    \cf6 \strokec6 int\cf4 \strokec4  sock_server;  \cf2 \strokec2 /* Socket on which server listens to clients */\cf4 \cb1 \strokec4 \
\
\cb3    \cf6 \strokec6 struct\cf4 \strokec4  sockaddr_in server_addr;  \cf2 \strokec2 /* Internet address structure that\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2                                         stores server address */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3    \cf6 \strokec6 unsigned\cf4 \strokec4  \cf6 \strokec6 short\cf4 \strokec4  server_port;  \cf2 \strokec2 /* Port number used by server (local port) */\cf4 \cb1 \strokec4 \
\
\cb3    \cf6 \strokec6 struct\cf4 \strokec4  sockaddr_in client_addr;  \cf2 \strokec2 /* Internet address structure that\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2                                         stores client address */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3    \cf6 \strokec6 unsigned\cf4 \strokec4  \cf6 \strokec6 int\cf4 \strokec4  client_addr_len;  \cf2 \strokec2 /* Length of client address structure */\cf4 \cb1 \strokec4 \
\
\cb3    \cf6 \strokec6 char\cf4 \strokec4  sentence[STRING_SIZE];  \cf2 \strokec2 /* receive message */\cf4 \cb1 \strokec4 \
\cb3    \cf6 \strokec6 char\cf4 \strokec4  modifiedSentence[STRING_SIZE]; \cf2 \strokec2 /* send message */\cf4 \cb1 \strokec4 \
\cb3    \cf6 \strokec6 unsigned\cf4 \strokec4  \cf6 \strokec6 int\cf4 \strokec4  msg_len;  \cf2 \strokec2 /* length of message */\cf4 \cb1 \strokec4 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  bytes_sent, bytes_recd; \cf2 \strokec2 /* number of bytes sent or received */\cf4 \cb1 \strokec4 \
\cb3    \cf6 \strokec6 unsigned\cf4 \strokec4  \cf6 \strokec6 int\cf4 \strokec4  i;  \cf2 \strokec2 /* temporary loop variable */\cf4 \cb1 \strokec4 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  successfulDataPackets = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  bytesDeliveredToUser = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  duplicatePackets = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  packetsDroppedDueToLoss = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  allPacketsReceived = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  acksWithoutLoss = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  droppedACKs = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3    FILE *fp;\cb1 \
\cb3    \cf2 \strokec2 /* open a socket */\cf4 \cb1 \strokec4 \
\cb3    fp = \cf8 \strokec8 fopen\cf4 \strokec4 (\cf7 \strokec7 "output.txt"\cf4 \strokec4 , \cf7 \strokec7 "w"\cf4 \strokec4 );\cb1 \
\cb3    \cf8 \strokec8 fprintf\cf4 \strokec4 (fp,\cf7 \strokec7 "Hello there"\cf4 \strokec4 );\cb1 \
\cb3    \cf5 \strokec5 if\cf4 \strokec4  ((sock_server = \cf8 \strokec8 socket\cf4 \strokec4 (PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < \cf9 \strokec9 0\cf4 \strokec4 ) \{\cb1 \
\cb3       \cf8 \strokec8 perror\cf4 \strokec4 (\cf7 \strokec7 "Server: can't open datagram socket\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 );\cb1 \
\cb3       \cf8 \strokec8 exit\cf4 \strokec4 (\cf9 \strokec9 1\cf4 \strokec4 );\cb1 \
\cb3    \}\cb1 \
\
\cb3    \cf2 \strokec2 /* initialize server address information */\cf4 \cb1 \strokec4 \
\
\cb3    \cf8 \strokec8 memset\cf4 \strokec4 (&server_addr, \cf9 \strokec9 0\cf4 \strokec4 , \cf6 \strokec6 sizeof\cf4 \strokec4 (server_addr));\cb1 \
\cb3    server_addr.\cf11 \strokec11 sin_family\cf4 \strokec4  = AF_INET;\cb1 \
\cb3    server_addr.\cf11 \strokec11 sin_addr\cf4 \strokec4 .\cf11 \strokec11 s_addr\cf4 \strokec4  = \cf8 \strokec8 htonl\cf4 \strokec4  (INADDR_ANY);  \cf2 \strokec2 /* This allows choice of\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \strokec2                                         any host interface, if more than one\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2                                         are present */\cf4 \cb1 \strokec4 \
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb3    server_port = SERV_UDP_PORT; \cf2 \strokec2 /* Server will listen on this port */\cf4 \cb1 \strokec4 \
\cb3    server_addr.\cf11 \strokec11 sin_port\cf4 \strokec4  = \cf8 \strokec8 htons\cf4 \strokec4 (server_port);\cb1 \
\
\cb3    \cf2 \strokec2 /* bind the socket to the local server port */\cf4 \cb1 \strokec4 \
\
\cb3    \cf5 \strokec5 if\cf4 \strokec4  (\cf8 \strokec8 bind\cf4 \strokec4 (sock_server, (\cf6 \strokec6 struct\cf4 \strokec4  sockaddr *) &server_addr,\cb1 \
\cb3                                     \cf6 \strokec6 sizeof\cf4 \strokec4  (server_addr)) < \cf9 \strokec9 0\cf4 \strokec4 ) \{\cb1 \
\cb3       \cf8 \strokec8 perror\cf4 \strokec4 (\cf7 \strokec7 "Server: can't bind to local address\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 );\cb1 \
\cb3       \cf8 \strokec8 close\cf4 \strokec4 (sock_server);\cb1 \
\cb3       \cf8 \strokec8 exit\cf4 \strokec4 (\cf9 \strokec9 1\cf4 \strokec4 );\cb1 \
\cb3    \}\cb1 \
\
\cb3    \cf2 \strokec2 // User input for the ACKLossRate and packetLossRate\cf4 \cb1 \strokec4 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Please input an ACK Loss Rate:\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 );\cb1 \
\cb3    \cf8 \strokec8 scanf\cf4 \strokec4 (\cf7 \strokec7 "%f"\cf4 \strokec4 , &inputACKLossRate);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Please input a Packet Loss Rate:\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 );\cb1 \
\cb3    \cf8 \strokec8 scanf\cf4 \strokec4 (\cf7 \strokec7 "%f"\cf4 \strokec4 , &inputPacketLossRate);\cb1 \
\
\cb3    \cf2 \strokec2 /* wait for incoming messages in an indefinite loop */\cf4 \cb1 \strokec4 \
\
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Waiting for incoming messages on port %hu\cf10 \strokec10 \\n\\n\cf7 \strokec7 "\cf4 \strokec4 ,\cb1 \
\cb3                            server_port);\cb1 \
\
\cb3    client_addr_len = \cf6 \strokec6 sizeof\cf4 \strokec4  (client_addr);\cb1 \
\
\cb3    \cf5 \strokec5 for\cf4 \strokec4  (;;) \{\cb1 \
\cb3        \cf8 \strokec8 memset\cf4 \strokec4 (sentence, \cf9 \strokec9 0\cf4 \strokec4 , STRING_SIZE );\cb1 \
\cb3        \cf6 \strokec6 struct\cf4 \strokec4  dataPacket temp;\cb1 \
\cb3        bytes_recd = \cf8 \strokec8 recvfrom\cf4 \strokec4 (sock_server, &temp, \cf6 \strokec6 sizeof\cf4 \strokec4 (temp), \cf9 \strokec9 0\cf4 \strokec4 ,\cb1 \
\cb3                      (\cf6 \strokec6 struct\cf4 \strokec4  sockaddr *) &client_addr, &client_addr_len);\cb1 \
\cb3         \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "received: %s\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 , temp.\cf11 \strokec11 data\cf4 \strokec4 );\cb1 \
\cb3         allPacketsReceived+=\cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\
\cb3         dataLength = temp.\cf11 \strokec11 dataCount\cf4 \strokec4 ;\cb1 \
\cb3         \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Packet has size: %d\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 , dataLength);\cb1 \
\cb3         \cf5 \strokec5 if\cf4 \strokec4  (dataLength==\cf9 \strokec9 0\cf4 \strokec4 )\{\cb1 \
\cb3             \cf5 \strokec5 break\cf4 \strokec4 ;\cb1 \
\cb3         \}\cb1 \
\cb3         receivedSequence = temp.\cf11 \strokec11 sequenceNumber\cf4 \strokec4 ;\cb1 \
\cb3         \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Sequence Number is: %d\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 , receivedSequence);\cb1 \
\
\cb3         \cf6 \strokec6 int\cf4 \strokec4  pl = \cf8 \strokec8 packetLoss\cf4 \strokec4 ();\cb1 \
\cb3         \cf5 \strokec5 if\cf4 \strokec4  (pl==\cf9 \strokec9 0\cf4 \strokec4 )\{\cb1 \
\cb3             packetsDroppedDueToLoss +=\cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3             \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 packet %d loss\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 ,temp.\cf11 \strokec11 sequenceNumber\cf4 \strokec4 );\cb1 \
\cb3         \}\cb1 \
\cb3         \cf5 \strokec5 else\cf4 \strokec4 \{\cb1 \
\cb3             \cf5 \strokec5 if\cf4 \strokec4  (expectedSequence != receivedSequence && receivedSequence == \cf9 \strokec9 1\cf4 \strokec4 )\{\cb1 \
\cb3                 duplicatePackets+=\cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3                 ackSequence = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3                 \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Packet is duplicate, Sending ACK: %d\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 , ackSequence);\cb1 \
\cb3             \}\cb1 \
\cb3             \cf5 \strokec5 else\cf4 \strokec4  \cf5 \strokec5 if\cf4 \strokec4 (expectedSequence != receivedSequence && receivedSequence == \cf9 \strokec9 0\cf4 \strokec4 )\{\cb1 \
\cb3                 duplicatePackets+=\cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3                 ackSequence = \cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3                 \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Packet is duplicate, Sending ACK: %d\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 , ackSequence);\cb1 \
\cb3             \}\cb1 \
\cb3             \cf5 \strokec5 else\cf4 \strokec4  \cf5 \strokec5 if\cf4 \strokec4 (expectedSequence == receivedSequence && receivedSequence == \cf9 \strokec9 1\cf4 \strokec4 )\{\cb1 \
\cb3                 \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Packet received with sequence number: %d\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 , receivedSequence);\cb1 \
\cb3                 \cf8 \strokec8 fprintf\cf4 \strokec4 (fp,\cf7 \strokec7 "%s\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 ,temp.\cf11 \strokec11 data\cf4 \strokec4 );\cb1 \
\cb3                 expectedSequence = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3                 ackSequence = \cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3             \}\cb1 \
\cb3             \cf5 \strokec5 else\cf4 \strokec4  \cf5 \strokec5 if\cf4 \strokec4 (expectedSequence == receivedSequence && receivedSequence == \cf9 \strokec9 0\cf4 \strokec4 )\{\cb1 \
\cb3                 \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Packet received with sequence number: %d\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 , receivedSequence);\cb1 \
\cb3                 \cf8 \strokec8 fprintf\cf4 \strokec4 (fp,\cf7 \strokec7 "%s\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 ,temp.\cf11 \strokec11 data\cf4 \strokec4 );\cb1 \
\cb3                 expectedSequence = \cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3                 ackSequence = \cf9 \strokec9 0\cf4 \strokec4 ;\cb1 \
\cb3             \}\cb1 \
\cb3             \cf5 \strokec5 else\cf4 \strokec4  \{\cb1 \
\cb3                 \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "Error on comparing sequence numbers\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 );\cb1 \
\cb3                 EXIT_FAILURE;\cb1 \
\cb3             \}\cb1 \
\
\
\cb3             \cf2 \strokec2 /* prepare the ack to send */\cf4 \cb1 \strokec4 \
\
\cb3             \cf8 \strokec8 sprintf\cf4 \strokec4 (ack, \cf7 \strokec7 "%d"\cf4 \strokec4 , ackSequence);\cb1 \
\cb3             \cf2 \strokec2 // msg_len = bytes_recd;\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 // for (i=0; i<msg_len; i++)\cf4 \cb1 \strokec4 \
\cb3             \cf2 \strokec2 //    modifiedSentence[i] = toupper (sentence[i]);\cf4 \cb1 \strokec4 \
\
\
\
\cb3             \cf2 \strokec2 /* send message */\cf4 \cb1 \strokec4 \
\
\cb3             \cf6 \strokec6 int\cf4 \strokec4  al = \cf8 \strokec8 ackLoss\cf4 \strokec4 ();\cb1 \
\cb3             \cf5 \strokec5 if\cf4 \strokec4  (al==\cf9 \strokec9 1\cf4 \strokec4 )\{\cb1 \
\cb3                 successfulDataPackets+=\cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3                 bytesDeliveredToUser+=temp.\cf11 \strokec11 dataCount\cf4 \strokec4 ;\cb1 \
\cb3                 acksWithoutLoss+=\cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3                 \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 returning this one\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 );\cb1 \
\cb3                 bytes_sent = \cf8 \strokec8 sendto\cf4 \strokec4 (sock_server, ack, \cf9 \strokec9 2\cf4 \strokec4 , \cf9 \strokec9 0\cf4 \strokec4 ,\cb1 \
\cb3                     (\cf6 \strokec6 struct\cf4 \strokec4  sockaddr*) &client_addr, client_addr_len);\cb1 \
\cb3             \}\cb1 \
\cb3             \cf5 \strokec5 else\cf4 \strokec4  \cf5 \strokec5 if\cf4 \strokec4  (al==\cf9 \strokec9 0\cf4 \strokec4 )\{\cb1 \
\cb3                 droppedACKs+=\cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3                 packetsDroppedDueToLoss +=\cf9 \strokec9 1\cf4 \strokec4 ;\cb1 \
\cb3                 \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 ACK %s lost\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 , ack);\cb1 \
\cb3             \}\cb1 \
\cb3             \cf5 \strokec5 else\cf4 \strokec4 \{\cb1 \
\cb3                 \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7  ISSUE\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 );\cb1 \
\cb3             \}\cb1 \
\cb3         \}\cb1 \
\cb3    \}\cb1 \
\cb3    \cf6 \strokec6 int\cf4 \strokec4  totalAcks = droppedACKs+acksWithoutLoss;\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 Successful Data Packets: %d"\cf4 \strokec4 ,successfulDataPackets);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 Bytes Delivered to Users: %d"\cf4 \strokec4 ,bytesDeliveredToUser);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 Duplicate Packets: %d"\cf4 \strokec4 ,duplicatePackets);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 Packets Dropped Due to Loss: %d"\cf4 \strokec4 ,packetsDroppedDueToLoss);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 All Packets Received: %d"\cf4 \strokec4 ,allPacketsReceived);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 ACKs Without Loss: %d"\cf4 \strokec4 , acksWithoutLoss);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 Dropped ACKs: %d"\cf4 \strokec4 ,droppedACKs);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 Total ACKs: %d"\cf4 \strokec4 ,totalAcks);\cb1 \
\cb3    \cf8 \strokec8 printf\cf4 \strokec4 (\cf7 \strokec7 "\cf10 \strokec10 \\n\cf7 \strokec7 "\cf4 \strokec4 );\cb1 \
\cb3    \cf8 \strokec8 fclose\cf4 \strokec4 (fp);\cb1 \
\cb3 \}\cb1 \
\
}